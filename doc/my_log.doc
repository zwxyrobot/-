2021.8.31
重构：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。
把一块代码抽取成一个独立的函数，进行提炼函数，再进行变量改名，使它们更简洁。对于一些变量的命名要简洁清晰。好的命名十分重要，但往往并非唾手可得。只有恰如其分地命名，才能彰显出将大函数分解成小函数的价值
2021.9.1
重构后的代码可能比重构前多，但是可读性更强，虽然言以简为贵，但可演化的软件却以明确为贵。好代码的检验标准就是人们是否能轻而易举地修改它。
变量作用域的扩展，其中的数据可变风险也随之增大。可以用函数组合成类或者函数组合成变换来限制需要对变量进行修改的代码量。
在临时变量过多的情况下，可以采用以查询取代临时变量从而减少临时变量。
a)	提炼函数：从一段代码中，理解其作用，然后将其提炼到一个独立的函数中，并以这段代码的用途为这个函数命名。
b)	内联函数：某些函数，其内部代码和函数名称同样清晰易读，可以去掉这个函数，直接使用其中的代码。或者在一群组织不甚合理的函数，将它们都内联到一个大型函数中，再重新提炼出小函数。
2021.9.2
一段代码在同时处理两件不同的事，它拆分成各自独立的模块，方便需要修改的时候，可以单独处理每个模块。
当某个数据的操作不仅仅局限于打印时，创建一个新类，为日后添加的业务逻辑留有余地。
分解一个冗长的函数，将变量抽取到函数里能使函数的分解过程更简单。
内联类与提炼类是相反的一个操作，前者是将一个类塞到另一个类中，后者是在一个类里面提炼出另一个类。“隐藏委托关系”和“移除中间人”也是相反的一个操作，前者是防止受托类修改了接口，波及通过服务对象使用它的所有客户端；后者是当受托类的特性比较多时候，应该让客户端直接调用受托类。
值对象与引用对象之间可以互相反向重构，值对象在分布式系统和并发系统中尤为有用，当几个对象共享一个对象，几个对象都能看见对共享对象的修改，引用对象就更合适。
代码简洁之道：
无论是给函数、变量、参数、类和封包命名，都要做到言道意到、意到言道。使读者只看名字就可以清楚其含义。
函数要精炼简短，确保函数只做一件事。
代码的注释并不绝对的好，但是恰当的注释会弥补代码表达意图的失败。好的代码包括法律信息、意图解释等。当然也要避免一些多余的、误导的、日志性等注释。
代码格式：包括横向格式、水平对齐、缩进等规范准则。
2021.9.3
《代码简洁之道》
第六章讨论的是对象和数据结构：对象将数据隐藏抽象化，曝露了操作数据的函数；而数据结构暴露了其数据。过程方式代码便于在不改动既有数据结构的基础下添加新函数，而面向对象代码便于在不改动既有函数的情况下添加新类。方法不应调用由任何函数返回的对象的方法。精炼的数据结构是只有公共变量，没有函数的类。
第七章对错误处理（异常）的讲解。将错误处理与主逻辑隔离开。
第八章的内容对实际开发有重要的指导意义，在使用第三方工具时，如何将这些东西整洁的纳入到我们的系统中，这时就需要考虑系统边界的问题。
第九章的内容是单元测试。包括测试代码的规范，方法以及遵守的规则。
第十章介绍类的设计。类自顶向下，善用保护成员；SRP原则：类或模块应有且只有一条加以修改的理由。
第十一章是关于系统设计的内容。包括了对依赖注入、代理模式以及AOP的探讨。
第十二章探讨了系统的迭代式演进。确保系统可测试性，然后对代码进行重构。
第十三章讨论并发编程。包括它的优点以及难点，并发的防御原则以及执行模型。
第十四章以一个案例来讲解对代码的持续改进。
第十五章到第十七章以Java的Junit框架以及SeriaDate库为例子讲述重构。
2021.9.6
学习git的使用：
包括：git的基本概念、特点以及简单使用方法。
下载git并行简单操作：包括本地库的创建、远程库的创建（github）、文件的上传等。
上传文件前操作：
1)	将文件加入暂存库：git add（文件名）;
2)	将文件加入版本库：git commit -m “message”,其中message是对commit的一个说明，包括功能、格式、重构等;
3)	最后将文件发布到远程库：git push。以github为例，执行git push后会出现：
Username：github的账户名
Password：是github的个人访问令牌。（2021年8月13日09:00PST（北京时间14日0点）开始，在GitHub.com上认证Git操作时将不再接受账户密码,所有需要认证的Git操作将需要基于令牌的认证）。
CMake基础学习：跨平台的安装(编译)工具,可以用简单的语句来描述所有平台的安装(编译过程)。
1)	编辑CMakeLists.txt，编译简单c++文件；
2)	编辑CMakeLists.txt，编译静态/动态库；
2021.9.7
CMake基础学习
添加动态库和添加静态库方法相同，区别是库的类型。
添加库及使用主要包括：
	添加静态/动态库（add_library（））；
	添加库的头文件目录（target_include_directories（））；
	添加可执行文件（add_executable（））；
	添加可执行的头文件目录（target_include_directories（））；
	链接库（target_link_libraries（））；
同时编译静态库和动态库也如此。
相同文件名同时生成静态和动态库：
命令行定义的宏变量（target_compile_definitions（））进行区分。
list用于列表操作：
对列表的操作分为读取、查找、修改、排序。通过list可以更加方便的多个工程进行编译。

2021.9.8
CMake基础学习
包括：cmake基本控制语法、宏和函数（区别1：函数是有范围的，而宏没有；区别2：函数很难将计算结果传出来，使用宏就可以将一些值简单的传出来）、运行其他程序。
Makefile基础学习
makefile的规则：target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。
注意：makefile中的命令，必须要以Tab键开始。
简单案例：
1.hello:main.o hello.o				
2.	g++ -o	hello main.o	hello.o
3.main.o:main.cpp hello.h
4.	g++ -c	main.cpp 
5.test.o:hello.cpp hello.h
6.	g++ -c	hello.cpp
主要文件包括：main.cpp、hello.h、hello.cpp
makefile中三个非常有用的变量：
$@：目标文件；$^：所有的依赖文件；$<：第一个依赖文件
上面内容就可变成：
1.hello:main.o hello.o				
2.	g++ -o	$@  $^
3.main.o:main.cpp hello.h
4.	g++ -c	$< 
5.test.o:hello.cpp hello.h
6.	g++ -c	$<
基于Makefile的缺省规则.cpp.o：(表示所有的.o文件都是依赖与相应的.cpp文件的)
因此上面内容可简化为：
1.hello:main.o hello.o				
2.	g++ -o	$@  $^
3..cpp.o:
4.	g++ -c	$< 
2021.9.9
Makefile基础学习
书写规则：
伪目标不产生依赖关系只作为一个标签，用.PHONY进行标记，如.PHONY ：clean。删除过程文件时候可以用rm命令，例如rm *.o，删除所有.o文件。
在makefile中，要进行伪目标的设置：
○1.PHONY ：clean
○2clean ：
○3	rm *.o
但是直接执行make后无法删除.o文件，需要输入make clean命令。
书写命令：
显示：makefile中将@放在命令行前，则此操作不会显示出来。通过echo可以将想要的信息打印到屏幕上。
执行：当需要把第1条命令结果传输给第2条时，1，2命令放一行并用分号隔开。
一般项目子目录多时，通常会进行嵌套make,而不是所有命令都写入一个makefile文件中。
变量的使用：
需要在变量名前加$并用括号将变量括起来；可以使用变量来构造变量的值；CFLAGS可以设置全局变量，包括在嵌套的makefile中使用；
函数的使用：
makefile中函数的使用也是以$开头的；循环函数foreach、条件语句if、创建新的参数化的函数call、origin函数用来告诉参数的来源。
2021.9.10












 
Github令牌：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
git remote set-url origin https://github.com/15529278331/test2.git（更改远程仓库指向）


Ceres Solver是一个开源C++库，用于建模和解决大型复杂优化问题。它可用于解决具有边界约束的非线性最小二乘问题和一般无约束优化问题。


